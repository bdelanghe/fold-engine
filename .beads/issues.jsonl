{"id":"bdelanghe-014","title":"Add IPFS/IPLD content addressing layer","description":"Integrate IPFS/IPLD for immutable content addressing. Separate conceptual identity (URL @id) from content identity (CID basis:cid). Add basis vocabulary terms: basis:cid (ipfs://\u003ccid\u003e), basis:contentCid, basis:bundleCid, basis:codec, basis:canonicalSerialization. This gives Git-like determinism: @id = branch name, CID = commit hash.","status":"open","priority":1,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:07:03.540631-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:07:03.540631-05:00","dependencies":[{"issue_id":"bdelanghe-014","depends_on_id":"bdelanghe-nke","type":"blocks","created_at":"2026-01-25T14:07:14.720347-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-0sh","title":"Expose SPARQL endpoint as MCP tool for agents","description":"Create MCP (Model Context Protocol) tool that exposes SPARQL queries to AI agents. Enables: 'AI-native websites stop being vibes and start being protocols.' Agents can query the RDF graph directly using SPARQL patterns. This makes the knowledge graph machine-navigable and agent-friendly.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:37:12.720781-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:37:12.720781-05:00","dependencies":[{"issue_id":"bdelanghe-0sh","depends_on_id":"bdelanghe-f8h","type":"blocks","created_at":"2026-01-25T14:37:33.71005-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-1kw","title":"Build link resolver for internal node resolution","description":"Create deterministic resolve(targetToken) -\u003e @id | error function. Handle: 1) Typed internal links [[citation:X]], [[concept:Y]], [[page:Z]] 2) Raw internal IDs (https://site/path/#section) 3) External URLs (keep as external edge). Core machinery for graph integrity validation.","status":"open","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:36.263248-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:54:36.263248-05:00","dependencies":[{"issue_id":"bdelanghe-1kw","depends_on_id":"bdelanghe-9lu","type":"blocks","created_at":"2026-01-25T13:55:10.670055-05:00","created_by":"Robert DeLanghe"},{"issue_id":"bdelanghe-1kw","depends_on_id":"bdelanghe-nke","type":"blocks","created_at":"2026-01-25T13:58:23.562936-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-1vn","title":"Add schema.org WebPage schema","description":"Define a strict schema.org WebPage profile for Unfold: create Zod schema and JSON Schema docs, wire into schema registries, and support strict validation artifacts.","status":"open","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T16:32:40.357964-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T16:32:40.357964-05:00"}
{"id":"bdelanghe-2cz","title":"Implement JSON-LD Framing for structural extraction","description":"Add W3C JSON-LD Framing for structure-aware filtering. Not a query language, but constrained search + reshape operation. Supply frame describing @type and properties, get matching subgraph. Good for: filtering by @type, extracting subgraphs, deterministic projections, building APIs. Complements SPARQL.","status":"open","priority":1,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:37:10.685763-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:37:10.685763-05:00","dependencies":[{"issue_id":"bdelanghe-2cz","depends_on_id":"bdelanghe-f8h","type":"blocks","created_at":"2026-01-25T14:37:33.112256-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-2wb","title":"Implement canonical serialization for deterministic CIDs","description":"Create canonical JSON-LD serialization format to ensure same content always produces same CID. Define normalization rules: sorted keys, consistent whitespace, deterministic @context expansion. Needed for basis:canonicalSerialization and repro builds.","status":"open","priority":1,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:07:04.504981-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:07:04.504981-05:00","dependencies":[{"issue_id":"bdelanghe-2wb","depends_on_id":"bdelanghe-014","type":"blocks","created_at":"2026-01-25T14:07:15.176564-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-4u1","title":"Test beads integration","description":"Verify beads is working correctly in this repository","status":"closed","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:52:34.279115-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:52:50.61907-05:00","closed_at":"2026-01-25T13:52:50.61907-05:00","close_reason":"Test successful"}
{"id":"bdelanghe-5cm","title":"Add LD Patch format support for partial RDF updates","description":"Implement W3C LD Patch format for HTTP PATCH operations on Linked Data resources. Enables granular edits without whole-document replacement. Use as PATCH payload format for LDP operations.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:22.196464-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:54:22.196464-05:00","dependencies":[{"issue_id":"bdelanghe-5cm","depends_on_id":"bdelanghe-vv8","type":"blocks","created_at":"2026-01-25T13:55:12.16295-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-76s","title":"Implement RDF Dataset Canonicalization (URDNA2015)","description":"Add W3C RDF Dataset Canonicalization for stable hashing and indexing. Enables: content addressing, deduplication, Merkle-DAG storage (IPFS integration), inverted indices on predicates/literals. Critical for basis:cid determinism and repro builds. Indexing step for scalable search.","status":"closed","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:37:11.367093-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:48:46.511861-05:00","closed_at":"2026-01-25T14:48:46.511861-05:00","close_reason":"RDF canonicalization implemented: deterministic hashing, basis:cid enrichment, Zod validation, 21 tests passing","dependencies":[{"issue_id":"bdelanghe-76s","depends_on_id":"bdelanghe-nke","type":"blocks","created_at":"2026-01-25T14:37:32.440416-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-77","title":"Expand SHACL shapes to mirror Zod schemas","description":"Align SHACL shapes with Zod: add constraints for page/refs/concept parity (min/max counts, datatype, pattern), add allowed enums (status, schema), and document how to extend shapes for new node types. Include tests for new constraints.","status":"closed","priority":1,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T15:32:57.636411-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T15:36:09.304213-05:00","closed_at":"2026-01-25T15:36:09.304213-05:00","close_reason":"Done"}
{"id":"bdelanghe-77h","title":"Define WebPage subtypes for vault roles","description":"You’re building something deliciously strange and rigorous: a schema-first publishing surface for cognitive objects—Obsidian notes → deterministic builds → JSON-LD → AI-legible pages → contracts and validation.\n\nSo when Schema.org lists: AboutPage, FAQPage, ItemPage, ProfilePage, QAPage, CollectionPage, SearchResultsPage, etc., the real question is: which of these actually map onto the ontology of your vault + Fold engine?\n\nCore mental model\n\nYour project has three major page roles:\n1) Concept / Note nodes\n2) Indexes / folds / navigators\n3) System + meta surfaces\n\nItemPage — extremely relevant\n\nItemPage is a page focused on a single item or entity. This maps to an Obsidian note / Fold object / schema-defined artifact / cognitive concept. Most notes should be ItemPage with mainEntity → DefinedTerm | CreativeWork | Dataset | SoftwareSourceCode | Concept.\n\nCollectionPage — very relevant\n\nFolder indexes, vault section pages, fold views, topic hubs. These should be CollectionPage with hasPart → ItemPage or mainEntity → ItemList.\n\nAboutPage — relevant for system docs\n\nUse for “What is Fold?”, publishing rules, design principles, schemas, governance, meta-architecture.\n\nFAQPage / QAPage — selectively useful\n\nUse for explainer sections, canonical questions, onboarding surfaces. QAPage is useful if structured questions/comments are added later.\n\nProfilePage — likely later\n\nUseful for authors/personas/contributors. ProfilePage with mainEntity → Person | Organization | SoftwareAgent.\n\nSearchResultsPage — only if you expose query UIs\n\nWhat to standardize\n\n| Vault Page Role | Schema Type |\n| -------------- | ----------- |\n| Note / concept | ItemPage |\n| Folder index | CollectionPage |\n| Fold view | CollectionPage |\n| System docs | AboutPage |\n| FAQ | FAQPage |\n| Author | ProfilePage |\n| Search | SearchResultsPage |\n\nArchitectural insight\n\nWebPage is the wrapper; mainEntity holds the semantics. Example:\n- WebPage (ItemPage)\n  mainEntity → basis:FoldObject\n\nSummary\n\nHighest value WebPage subtypes: ItemPage, CollectionPage, AboutPage, FAQPage/QAPage, ProfilePage, SearchResultsPage. Everything else is noise.\n\nNext step\n\nDefine a canonical JSON-LD block for the Unfold root that pages inherit, then override hasPart/mainEntity/creativeWorkStatus per fold.\n","status":"open","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T18:56:18.518971-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T18:56:18.518971-05:00"}
{"id":"bdelanghe-7a0","title":"Lume JSON-LD object output (vault compiler)","description":"Use Lume as a deterministic compiler from vault -\u003e JSON-LD object space. Emit per-note .jsonld alongside/without HTML, preserving canonical paths. Add preprocess to build JSON-LD from frontmatter/body, output sibling .jsonld files, and define canonical URL scheme (e.g., /objects/\u003cslug\u003e.jsonld or /\u003cslug\u003e/index.jsonld). Include validation hooks (SHACL/JSON Schema), link expansion, and optional dataset/index outputs (e.g., /objects/index.jsonld, VoID).","status":"open","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T15:45:33.928791-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T15:45:33.928791-05:00"}
{"id":"bdelanghe-7gc","title":"Define schema.org base model for web building","description":"Your current structure maps cleanly onto a small, consistent subset of schema.org CreativeWork/WebPage semantics. Here’s the model I’d treat as “our base,” i.e. the contract profile your JSON-LD objects should follow.\n\nBase object model (schema.org-first)\n\n1) Site root\n\nschema:WebSite\n- Represents the whole published vault/site.\n- Pages are part of it via schema:isPartOf.\n\nThis is the “container of containers.”\n\n(You don’t need it, but it’s the correct top anchor when you want hierarchy.)\n\n2) Pages\n\nschema:WebPage\nYour vault/pages/*.jsonld should be WebPages.\n\nKey relationships:\n- Page → Sections: schema:hasPart\n- Section → Page: schema:isPartOf (inverse of hasPart)\n- Page → Site: schema:isPartOf (optional but strong)\n\nSo your basic tree is:\n\nWebSite → hasPart(WebPage)\nWebPage → hasPart(WebPageElement | CreativeWork)\nWebPageElement → isPartOf(WebPage)\n\n3) Sections\n\nschema:WebPageElement\nThis is the schema.org-native way to represent “parts of a page” like sections, nav, footer, etc.\n\nIn your system:\n- each section is a node with its own @id (usually page#section)\n- each section is linked using:\n  - schema:isPartOf → its page\n  - optionally, the page lists them via schema:hasPart\n\nThis is how you get explicit parent/child structure in the graph, not just in HTML.\n\n4) References (external citations)\n\nBest fit: schema:CreativeWork\nYour vault/refs/*.jsonld entries are “things you cite.”\n\nMinimal ref node:\n- @type: schema:CreativeWork (or schema:WebPage if it’s specifically a page)\n- schema:name\n- schema:url\n\nThen pages/sections connect to refs using:\n- schema:citation\n\nThis gives you: “this section cites that document.”\n\n5) Vocabulary / ontology terms (Basis vocab)\n\nBest fit: schema:DefinedTerm (and optionally schema:DefinedTermSet)\nYour vault/vocab/basis.jsonld objects like …#Fold, …#Unfold, …#Transform want to be terms, not pages.\n\nMinimal term node:\n- @type: schema:DefinedTerm\n- schema:name\n- schema:description\n- optional schema:sameAs (Wikidata, docs, canonical spec URL)\n\nThis is exactly “meaning dictionary.”\n\nLink types: internal vs external (how we model it)\n\nInternal relationships (graph edges)\n\nUse node-to-node links via IDs (not raw strings):\n- schema:hasPart / schema:isPartOf for hierarchy\n- schema:mentions when a node is referenced but not necessarily “about”\n- schema:about when a page/section is about a concept/term (great for vocab integration)\n\nExternal links\n\nUse URL-bearing properties:\n- schema:url on CreativeWork/Ref nodes\n- schema:sameAs for identity equivalence\n- schema:citation can point to a URL or to a CreativeWork node, but prefer nodes (more structured)\n\nOptional “nice structure” objects\n\nIndex / navigation pages\n\nschema:CollectionPage\nUse this for “home page / index page / directory.”\n\nBreadcrumbs\n\nschema:BreadcrumbList (an ItemList)\nGreat if you want explicit parent chain structure.\n\nThe canonical “our structure” summary\n\nIf I had to describe your whole architecture in one typed graph:\n- WebSite contains WebPages\n- Each WebPage is composed of WebPageElements (sections)\n- Pages/sections cite CreativeWorks (refs)\n- Pages/sections are about/mention DefinedTerms (vocab concepts)\n\nThat is schema.org-native, SHACL-validatable, and strict-JSON-schema-friendly.\n\nReduced form\n\nYour base schema.org object stack is:\n- WebSite\n- WebPage\n- WebPageElement (sections)\n- CreativeWork (refs via citation)\n- DefinedTerm (+ DefinedTermSet) (your vocab)\n\nwith structure enforced by hasPart / isPartOf and content linkage via citation, about, mentions.","status":"closed","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T16:39:21.347208-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T16:54:40.1544-05:00","closed_at":"2026-01-25T16:54:40.1544-05:00","close_reason":"Implemented schema.org base model: added Zod + JSON Schema profiles for WebSite, WebPageElement, CreativeWork, DefinedTerm, DefinedTermSet; registered in schema registries and validator; updated schema docs."}
{"id":"bdelanghe-9lu","title":"Implement Cool URIs naming strategy for node identifiers","description":"Establish URI/IRI naming conventions following W3C Cool URIs best practices. Use slash URIs for pages (https://site/pages/cognitive-folding), hash URIs for vocabulary terms (https://site/vocab/basis#Fold). Document the hash vs 303 strategy and create resolver for both patterns.","status":"open","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:22.444312-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:54:22.444312-05:00","dependencies":[{"issue_id":"bdelanghe-9lu","depends_on_id":"bdelanghe-nke","type":"blocks","created_at":"2026-01-25T13:58:23.27946-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-ag4","title":"Add IPFS distribution option to DCAT catalog","description":"Extend DCAT catalog with IPFS distribution. Package vault as dataset with DCAT Distribution pointing to IPFS CID of release bundle (CAR file). Option C from architecture: vault release has bundle CID, each node has per-node CID. Enables content-addressable dataset distribution.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:07:05.017866-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:07:05.017866-05:00","dependencies":[{"issue_id":"bdelanghe-ag4","depends_on_id":"bdelanghe-zdl","type":"blocks","created_at":"2026-01-25T14:07:16.125915-05:00","created_by":"Robert DeLanghe"},{"issue_id":"bdelanghe-ag4","depends_on_id":"bdelanghe-014","type":"blocks","created_at":"2026-01-25T14:07:16.586151-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-ahx","title":"Add PROV-O provenance tracking with CIDs","description":"Implement W3C PROV-O for build ledger. Track: prov:Entity (page node), prov:wasGeneratedBy (build step), prov:wasDerivedFrom (source notes), with CID as immutable artifact fingerprint. Creates traceable build artifact graph: 'this page came from these notes, built by this tool, at this time, and this CID proves the content.'","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:07:04.033825-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:07:04.033825-05:00","dependencies":[{"issue_id":"bdelanghe-ahx","depends_on_id":"bdelanghe-014","type":"blocks","created_at":"2026-01-25T14:07:15.676661-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-ath","title":"Update render pipeline to generate HTML from JSON-LD","description":"Modify pipeline/render.ts to consume JSON-LD nodes instead of markdown. Use Lume templates with JSON-LD data. For each node with @type basis:Page, render to HTML using templates. Inject JSON-LD as \u003cscript type='application/ld+json'\u003e in head. This makes JSON-LD vault → HTML website work end-to-end.","status":"closed","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:37:34.362683-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:41:48.082468-05:00","closed_at":"2026-01-25T14:41:48.082468-05:00","close_reason":"Render pipeline updated: JSON-LD loader implemented, tests passing, markdown removed","dependencies":[{"issue_id":"bdelanghe-ath","depends_on_id":"bdelanghe-nke","type":"blocks","created_at":"2026-01-25T14:38:08.474572-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-cts","title":"Add bidirectional link auto-generation (self-healing)","description":"Auto-generate inverse relationships for better ergonomics: If page has hasPart sections, auto-emit isPartOf back-links. Consider auto-creating stub ref notes for [[citation:X]] if missing (with build warning). Keeps authoring low-friction without sacrificing strictness.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:53.556136-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:54:53.556136-05:00"}
{"id":"bdelanghe-d8n","title":"Document SHACL JSON-LD vs Turtle guidance","description":"Yes — JSON-LD works just as well as Turtle for SHACL, as long as your SHACL engine can parse JSON-LD.\n\nThe SHACL spec is explicit about this: SHACL’s syntax is RDF, and you can use any RDF serialization (Turtle, JSON-LD, RDF/XML, etc.).\n\nThat said, there are practical tradeoffs.\n\nWhat’s true in theory\n\nSHACL consumes two RDF graphs:\n- Shapes Graph (your SHACL rules)\n- Data Graph (your JSON-LD content)\n\nBoth graphs can be written in Turtle or JSON-LD.\n\nWhat’s true in practice\n\nTurtle is better for authoring SHACL by hand\n\nReasons:\n- It’s compact and readable for RDF triples.\n- Prefixes make constraint definitions clean.\n- Most examples and community usage are Turtle-heavy.\n\nJSON-LD is better if your pipeline is “JSON-first”\n\nReasons:\n- You can keep everything JSON-native.\n- It’s easier to generate programmatically.\n- Fits your “JSONLD-first → render page from model” approach.\n\nThe main risk with JSON-LD: tooling variance\n\nSome validators handle Turtle flawlessly but are pickier about certain JSON-LD 1.1 patterns / contexts. When that happens, Turtle is the “safe fallback.”\n\nMy recommendation for your system\n\nUse both, but for different roles:\n- Write shapes in Turtle (shapes/*.ttl) for clarity and stability.\n- Generate data as JSON-LD (your site/vault objects).\n- The validator parses both into RDF internally anyway.\n\nThis gives you:\n- readable, maintainable constraints\n- JSON-native content pipeline\n- zero format drama\n\nReduced form\n\nYes: JSON-LD works as well as Turtle because SHACL reads RDF graphs and both are valid RDF serializations.\nTurtle is usually nicer for humans writing constraints; JSON-LD is nicer for generators.","status":"open","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T16:36:59.640863-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T16:36:59.640863-05:00"}
{"id":"bdelanghe-f3t","title":"Emit full vault as single JSON-LD object","description":"Add an artifact that emits the entire website/vault as a single JSON-LD object (graph document) containing all content nodes. The output should include one top-level JSON-LD object with @context and @graph entries for the whole vault, plus a WebSite root node that links to all WebPages. No parsing required; just generate the object from existing nodes.","notes":"Use the emitted single JSON-LD graph as a test fixture to ensure JSON Schema + SHACL validations pass in strict mode.","status":"open","priority":1,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T16:45:25.262283-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T16:47:57.25158-05:00"}
{"id":"bdelanghe-f8h","title":"Add SPARQL query support for graph search","description":"Implement W3C SPARQL 1.1 Query Language for RDF graphs. Pipeline: JSON-LD → expand/flatten → RDF triples → SPARQL query. Enable pattern matching (subject-predicate-object), filtering, joins across documents, relationship traversal, full graph searches. This is the canonical W3C search mechanism - maximum power, highest ceremony.","status":"open","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:37:09.939747-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:37:09.939747-05:00","dependencies":[{"issue_id":"bdelanghe-f8h","depends_on_id":"bdelanghe-76s","type":"blocks","created_at":"2026-01-25T14:37:31.800415-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-g56","title":"Map JSON-LD semantics to HTML/ARIA for semantic JSONL","description":"They’re related, but they live in different layers of reality.\n\nYour schema.org / JSON-LD structure helps machines understand what your content is about (SEO, agent ingestion, knowledge graphs).\nYour semantic HTML + ARIA roles help screen readers understand how to navigate and operate the page UI.\n\nSame content. Two different “views” of it.\n\nThe two stacks (clean split)\n\nA) Screen readers: accessibility tree (UI semantics)\n\nScreen readers mostly read the accessibility tree produced by the browser (derived from HTML + ARIA).\n\nInputs that matter:\n- semantic HTML elements (\u003cmain\u003e, \u003cnav\u003e, \u003cheader\u003e, \u003cbutton\u003e, headings)\n- ARIA roles and attributes (role=navigation, aria-label, aria-expanded, etc.)\n\nB) Schema.org JSON-LD: meaning graph (content semantics)\n\nJSON-LD provides structured data for “this is a WebPage / CreativeWork / DefinedTerm…” and how things relate conceptually.\n\nInputs that matter:\n- @type, @id\n- hasPart, isPartOf, citation, about, mentions\n\nThese do not drive screen reader navigation directly.\n\nHow they map to each other (your “section graph” idea)\n\nYour schema.org model:\n- WebPage\n- hasPart → WebPageElement (sections)\n- citation → CreativeWork (refs)\n- about → DefinedTerm (vocab)\n\nYour HTML / ARIA model:\n- \u003cmain\u003e (landmark)\n- \u003csection\u003e (region)\n- \u003ch2\u003e (heading)\n- links/buttons/etc with accessible names\n\nThe conceptual overlap is “sections and hierarchy,” but the mechanism is different.\n\nA section in JSON-LD is a node.\nA section in HTML is a DOM subtree.\nA section in accessibility is a region + heading (so screen readers can jump to it).\n\nWhat screen readers actually care about\n\nScreen readers tend to navigate using:\n- headings (H1/H2/H3 outline)\n- landmarks/regions (banner, nav, main, complementary, contentinfo)\n- links (link text quality)\n- controls (button/input roles + states)\n\nThat corresponds to:\n\nLandmark elements (best)\n\nUse native elements whenever possible:\n- \u003cheader\u003e (banner)\n- \u003cnav\u003e (navigation)\n- \u003cmain\u003e (main)\n- \u003caside\u003e (complementary)\n- \u003cfooter\u003e (contentinfo)\n\nThese often generate implicit landmark roles automatically.\n\nARIA roles (only when needed)\n\nUse ARIA when you don’t have a correct native element or you need labeling/state.\n\nWAI confirms ARIA exists to identify UI features, relationships, and state for assistive tech.\n\nThe key rule\n\nDo semantic HTML first; ARIA is patch glue.\n\nLandmark + semantic elements are the cleanest route for accessibility.\n\nSo what should you do in your generator?\n\nIf you’re generating HTML from JSON-LD, you want an explicit mapping layer:\n\nJSON-LD node → HTML structure rules\n- schema:WebPage → \u003carticle\u003e or just page document + \u003cmain\u003e\n- schema:WebPageElement → \u003csection\u003e with a heading and an id\n- schema:citation → \u003ca\u003e or footnote list; ensure link text is meaningful\n- schema:DefinedTerm references → \u003ca href=/vocab/...\u003eTerm\u003c/a\u003e\n\nAnd for accessibility:\n- page has exactly one \u003cmain\u003e\n- sections have heading structure (h2 inside main, h3 inside section)\n- navs labeled if multiple (aria-label=Primary)\n\nThat’s how the two worlds “snap together.”\n\nReduced form\n- Schema.org/JSON-LD = meaning graph (what things are).\n- Semantic HTML + ARIA = accessibility semantics (how users navigate/operate).\n- They align at the concept level (pages/parts/sections), but screen readers mostly ignore JSON-LD and follow the accessibility tree derived from HTML + ARIA.","status":"open","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T16:41:08.950704-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T16:41:08.950704-05:00"}
{"id":"bdelanghe-hv6","title":"Allow Deno tests to read vault fixtures","notes":"Running `docker compose run --rm unfold-test deno test` still fails because Deno throws `NotCapable` when reading `src/unfold/contracts/fixtures/*`, the local vault files now stored under `example-vault/`, and `/deno-dir/.../lightningcss_node.wasm` even after setting `SITE_URL` and `--allow-read/--allow-env`. The test runner needs explicit permission access (e.g., `deno test -A --allow-env=SITE_URL` or the same via `DENO_FLAGS`) and awareness of the renamed example vault so the suites can complete.","status":"open","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T22:10:59.524233-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T22:12:15.142115-05:00"}
{"id":"bdelanghe-jo2","title":"Define strict validation mental model","description":"Explicit Problem\n\nYou want our structure (and Schemarama CORE’s “parse → validate” model) expressed as a clean mental model: what the objects are, what the validators actually enforce, and what “deterministic strict validate” means in this world.\n\nDefinitions\n\nData Graph: your JSON-LD (pages/sections/refs/vocab) interpreted as RDF triples/quads.\n\nShapes Graph: your SHACL or ShEx rules, also expressed as RDF (SHACL) or as ShEx schema.\n\nFocus node: the node currently being validated by a shape.\n\nTargeting:\n- ShEx: “validate these nodes against this start shape”\n- SHACL: “validate nodes selected by sh:targetClass/targetNode/...\"\n\nbaseUrl / baseIRI: the base used to resolve relative IRIs during parsing; changing it can change node IDs and therefore validation outcomes.\n\nKnown Facts\n\nFrom your pasted “Schemarama CORE” model:\n- All inputs normalize into an RDF store before validation (e.g. n3.Store).\n- Validators produce a normalized failures list { baseUrl, store, failures[] }.\n- ShEx uses an explicit start shape.\n- SHACL uses target declarations.\n\nThese match the canonical SHACL / ShEx models.\n\nUser Constraints (inferred)\n- Deterministic “contract-like” behavior (repeatable runs, stable IDs, stable reports).\n- “Shape-driven meaning,” not “mystery tool did something.”\n- Want this to map cleanly onto your vault primitives (Page/Section/Ref/VocabTerm) and later your Fold engine.\n\nSlot-Based Schema\n\nSlots\n- input.data_format: jsonld | microdata | rdfa | nquads\n- input.data: string | file path\n- input.baseUrl: IRI\n- shapes.kind: shacl | shex\n- shapes.source: turtle | ShExJ\n- entrypoint: startShape IRI (ShEx only)\n- output.report: failures[] + (optional) serialized graph\n\nPhases\n1. Normalize → parse into RDF store\n2. Select focus nodes → ShEx start shape or SHACL targets\n3. Validate constraints → failures\n4. Emit → report/log/artifact\n\nDerived Conditions (the “strict validate” contract)\n\n1) Determinism is mostly about IDs\n\nYou called this correctly: baseUrl is part of the contract. If your JSON-LD has relative @id values (or relies on defaults), baseUrl decides the final resolved IRIs.\n\nStrict mode should therefore enforce:\n- every node has a stable @id (or you deliberately allow blank nodes)\n- baseUrl is always explicit in CI/local runs\n\n2) ShEx vs SHACL is “entrypoint semantics”\n\nYour mental model is correct:\n- ShEx = “validate (node, shape) pairs”; you pick a start shape (or a query producing start nodes).\n- SHACL = “validate all nodes targeted by the shapes graph.”\n\n3) Parsing errors masquerade as validation errors\n\nAlso correct: if parsing produces unexpected triples (wrong IRIs, missing literals, flattened structure), the validator will “correctly” complain about the wrong graph.\n\nSo strict mode should treat parsing as Phase 0, not an implementation detail.\n\nOutput (our structure, based on schema.org objects)\n\nThis is the minimal schema.org base graph you’re actually modeling:\n\nA) WebSite (optional but clean)\n\nschema:WebSite\n- anchor for the whole vault/site\n- pages can point to it via schema:isPartOf\n\nB) WebPage (the page object)\n\nschema:WebPage\n- your published page node\n- relations:\n  - schema:hasPart → section nodes\n  - schema:citation → ref nodes\n  - schema:about / schema:mentions → vocab terms\n\nC) WebPageElement (sections)\n\nschema:WebPageElement\n- each section is a first-class node (like …/pages/x#intro)\n- relations:\n  - schema:isPartOf → its page\n  - optionally nested parts via schema:hasPart\n\nThis is where “parent/child” becomes explicit in JSON-LD: the graph edges are the tree.\n\nD) CreativeWork (references)\n\nschema:CreativeWork (or schema:WebPage for a referenced web page)\n- refs live as nodes with:\n  - schema:name\n  - schema:url\n- cited by pages/sections using schema:citation\n\nE) DefinedTerm (vocabulary terms)\n\nschema:DefinedTerm (and optionally schema:DefinedTermSet)\n- your basis vocab nodes (Fold/Unfold/Transform)\n- connected via:\n  - schema:about (strong: “this section is about Fold”)\n  - schema:mentions (weak: “this section mentions Fold”)\n\nThis is the “SKOS-like meaning dictionary” role but using schema.org-native primitives.\n\nHow this relates to screen readers (and ARIA roles)\n\nThis is the crucial split:\n- schema.org JSON-LD expresses content meaning for crawlers/agents/graphs.\n- semantic HTML + ARIA expresses interactive/navigation meaning for assistive tech.\n\nJSON-LD does not build the accessibility tree. The browser builds that from HTML semantics and ARIA.\n\nSo your generator should treat this as a projection:\n\nWebPage → \u003cmain\u003e\nWebPageElement(section) → \u003csection\u003e + heading\nCreativeWork(ref) → \u003ca\u003e / footnote\nDefinedTerm → \u003ca href=\"/vocab/...\"\u003e\n\nStrict validate is the “graph is correct”; accessibility correctness is a separate check (“HTML landmarks + headings are correct”).\n\nSummary (Reduced Form)\n\nYour structure is: WebPage composed of WebPageElements, citing CreativeWorks, and referencing DefinedTerms, optionally under a WebSite. Validation is: parse JSON-LD into RDF, then run ShEx with a start shape or SHACL with targets; determinism depends heavily on stable @id and explicit baseUrl.\n\nNext step: treat “strict validate” as enforcing stable IDs + required schema.org typing + required hasPart/isPartOf edges across Page/Section/Ref/VocabTerm, and keep HTML/ARIA validation as an orthogonal build check.\n","status":"open","priority":2,"issue_type":"task","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T17:26:40.409288-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T17:26:40.409288-05:00"}
{"id":"bdelanghe-k1w","title":"Implement reachability validation (no orphan objects)","description":"Enforce that all objects are connected to the graph. Pick allowed roots (catalog, entrypoints), run BFS/DFS to compute reachable nodes. Fail if any non-exempt node is unreachable. Support exemptions for draft/private nodes and orphaned refs.","status":"closed","priority":1,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:53.041695-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T16:09:28.089571-05:00","closed_at":"2026-01-25T16:09:28.089574-05:00","dependencies":[{"issue_id":"bdelanghe-k1w","depends_on_id":"bdelanghe-xkc","type":"blocks","created_at":"2026-01-25T13:55:11.172571-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-nke","title":"Switch vault source from Obsidian markdown to JSON-LD objects","description":"Change architecture: Instead of Obsidian vault (markdown + YAML) → compile → JSON-LD, use JSON-LD vault → validate/transform → outputs. This simplifies: no markdown parsing, no frontmatter extraction, native @id resolution, direct graph validation. The vault becomes a directory of .jsonld files. Update inputs/ pipeline to read JSON-LD directly instead of markdown.","status":"closed","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:57:31.293958-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:34:11.989466-05:00","closed_at":"2026-01-25T14:34:11.989466-05:00","close_reason":"JSON-LD vault implemented: loader, validator, schemas, tests passing"}
{"id":"bdelanghe-qyr","title":"Add VoID vocabulary for graph statistics and linksets","description":"Implement W3C VoID (Vocabulary of Interlinked Datasets) as void.jsonld. Describe structural metadata, inter-dataset links, node sets, and linksets. Optional but useful for 'here are my node sets and linksets' discoverability.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:36.008132-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:54:36.008132-05:00"}
{"id":"bdelanghe-to1","title":"Add Hydra search discovery to API","description":"Implement Hydra Core Vocabulary for API-level search discovery. Define collections, filters, search templates (hydra:IriTemplate). Enables clients to discover search affordances. Example: /notes{?type,tag} with hydra:mapping. Makes search capabilities hypermedia-driven and discoverable.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:37:12.073379-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:37:12.073379-05:00"}
{"id":"bdelanghe-up4","title":"Research Solid PODs and LDP patterns","description":"Research Solid Project patterns for personal data pods, WAC permissions, and authentication flows.\n\nContext from user:\n- Solid POD = LDP containers + RDF resources + HTTP verbs + ACLs\n- Vault analogy: /notes/ ↔ /vault/, note.ttl ↔ note.md\n- Each note gets canonical IRI, directories become LDP containers\n- Frontmatter becomes RDF, backlinks are RDF predicates\n- Expose JSON-LD, agents query over HTTP\n\nKey questions:\n- Can fold-engine vault expose LDP-compatible interface?\n- Pod-to-pod sync patterns\n- Third-party app integration via SPARQL endpoint\n- Dataview queries → SPARQL translation\n- Content-addressed note IDs vs slug IDs\n\nThis is research to inform vault server abstraction + contracts architecture.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:53:27.836707-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:53:27.836707-05:00"}
{"id":"bdelanghe-utm","title":"Design RDF backing store for vault with SHACL constraints","description":"Treat each note as RDF resource: frontmatter → predicates, links → IRIs, tags → SKOS concepts. Expose JSON-LD view for publishing + SPARQL endpoint for agents + framed projections for bounded folds. Add SHACL validation (graph constraints): every Note has exactly one title, tags from controlled vocab, links must resolve. Aligned with deterministic folds, schema-bound views, auditability.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:48:47.623161-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:48:47.623161-05:00"}
{"id":"bdelanghe-v4n","title":"Add strict/dev validation modes for graph integrity","description":"Create two lint modes: Strict (CI gate) - bad links/orphans/duplicate IDs are errors. Dev (authoring) - bad links are errors, orphans are warnings with hints. Gate strict mode in CI via 'deno task ci'.","notes":"Tightened page hasPart id-only refs to be strict (no extra props) so oneOf resolves cleanly; strict validate now passes. Ran: docker compose run --rm -e UNFOLD_VALIDATE_MODE=strict unfold-test deno task validate; docker compose run --rm unfold-test deno test -A (98 passed).","status":"open","priority":1,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:53.293729-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T19:37:55.712865-05:00","dependencies":[{"issue_id":"bdelanghe-v4n","depends_on_id":"bdelanghe-k1w","type":"blocks","created_at":"2026-01-25T13:55:11.415853-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-vni","title":"Add full-text search over RDF triples","description":"Implement semantic search: SPARQL + text extensions, inverted indices over literals, embeddings layered on top. Provides: semantic search, deterministic filters, agent retrievability. Not standardized by W3C but common pattern. Integrate with SPARQL endpoint once available.","status":"open","priority":2,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T14:48:49.834017-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T14:48:49.834017-05:00"}
{"id":"bdelanghe-vv8","title":"Add LDP (Linked Data Platform) support for REST-style updates","description":"Implement W3C Linked Data Platform 1.0 spec for HTTP-based CRUD operations on RDF resources. Support POST (create), PUT (replace), PATCH (partial update), DELETE (remove) semantics for JSON-LD documents. Target: REST-style document updates over HTTP for vault resources.","status":"open","priority":1,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:21.94678-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:54:21.94678-05:00","dependencies":[{"issue_id":"bdelanghe-vv8","depends_on_id":"bdelanghe-zdl","type":"blocks","created_at":"2026-01-25T13:55:11.920134-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-xkc","title":"Implement graph validation pass for link integrity","description":"Build validation pass that enforces: I1) Target existence - every internal edge points to existing @id, I2) No duplicate @id values, I3) Ref integrity - every [[citation:X]] resolves to refs/X.md. Create node index, extract edges, validate all internal links. Fail on first bad link or collect all errors.","status":"closed","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:52.779807-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T16:01:24.49485-05:00","closed_at":"2026-01-25T16:01:24.494853-05:00","dependencies":[{"issue_id":"bdelanghe-xkc","depends_on_id":"bdelanghe-1kw","type":"blocks","created_at":"2026-01-25T13:55:10.921766-05:00","created_by":"Robert DeLanghe"}]}
{"id":"bdelanghe-zdl","title":"Add DCAT catalog for dataset-level indexing","description":"Implement W3C DCAT v3 catalog as catalog.jsonld. Catalog should list all datasets: pages, vocab, refs, and their distributions (.html, .md, .jsonld). This is the 'registry of everything that exists' and serves as the primary discovery mechanism.","status":"open","priority":0,"issue_type":"feature","owner":"1240090+bdelanghe@users.noreply.github.com","created_at":"2026-01-25T13:54:35.758988-05:00","created_by":"Robert DeLanghe","updated_at":"2026-01-25T13:54:35.758988-05:00","dependencies":[{"issue_id":"bdelanghe-zdl","depends_on_id":"bdelanghe-9lu","type":"blocks","created_at":"2026-01-25T13:55:11.670485-05:00","created_by":"Robert DeLanghe"},{"issue_id":"bdelanghe-zdl","depends_on_id":"bdelanghe-nke","type":"blocks","created_at":"2026-01-25T13:58:23.824497-05:00","created_by":"Robert DeLanghe"}]}
