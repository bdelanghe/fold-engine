<h1>project-notes</h1>
<h2>What we need to do</h2>
<ol>
<li>Content model</li>
</ol>
<ul>
<li>Define frontmatter schema (fields, types, required/optional).</li>
<li>Decide supported frontmatter formats (YAML only vs YAML/JSON/TOML).</li>
<li>Define JSON-LD mapping rules and vocabularies.</li>
</ul>
<ol start="2">
<li>File structure</li>
</ol>
<ul>
<li>Decide vault/site root (<code>/notes</code> or <code>/content</code>).</li>
<li>Standardize note naming and slug rules.</li>
<li>Decide where generated outputs live (<code>/dist</code>, <code>/public</code>).</li>
</ul>
<ol start="3">
<li>Build pipeline</li>
</ol>
<ul>
<li>Pick static site generator or custom build (e.g., Deno/Lume).</li>
<li>Parse frontmatter, validate schema, and fail on invalid notes.</li>
<li>Render Markdown to HTML.</li>
<li>Emit JSON and JSON-LD sidecars for each note.</li>
</ul>
<ol start="4">
<li>Obsidian compatibility</li>
</ol>
<ul>
<li>Keep Markdown + frontmatter readable in Obsidian.</li>
<li>Avoid build artifacts inside the vault.</li>
<li>Document required plugins (if any).</li>
</ul>
<ol start="5">
<li>GitHub Pages delivery</li>
</ol>
<ul>
<li>Disable Jekyll processing (add <code>.nojekyll</code>).</li>
<li>Choose deploy method (Pages from branch vs Actions).</li>
<li>If using Actions, add workflow to build and publish <code>/dist</code>.</li>
</ul>
<ol start="6">
<li>Minimal MVP</li>
</ol>
<ul>
<li>One example note with frontmatter schema.</li>
<li>One JSON-LD export.</li>
<li>One rendered HTML page with embedded JSON-LD.</li>
</ul>
<h2>Open questions</h2>
<ul>
<li>Which SSG/build tool do we want (Lume, Astro, custom Deno)?</li>
<li>Where should the vault live in this repo?</li>
<li>What schema versioning strategy do we want?</li>
<li>Build tool decision: use jaq for JSON folding.</li>
</ul>
<h2>Build stack</h2>
<ul>
<li>Deno for runtime and tasks.</li>
<li>Lume for static site generation.</li>
<li>@std/front-matter for parsing note metadata.</li>
<li>Zod for schema validation of frontmatter.</li>
</ul>
<h2>Notes: IPFS ecosystem vs ontology systems</h2>
<ul>
<li>Most IPFS tools are transport/persistence layers; they do not define domain
models.</li>
<li>IPFS itself is schema-agnostic: content-addressed bytes first.</li>
<li>Schema-adjacent exceptions:
<ul>
<li>IPLD: structural schemas for typed DAG nodes and traversal.</li>
<li>Ceramic: typed document schemas for streams/identity.</li>
<li>OrbitDB/Mahuta: database/indexing schema, not ontology.</li>
</ul>
</li>
<li>There are effectively no OWL/RDF/SHACL-style domain ontologies in this space.</li>
<li>Implication: treat IPFS as substrate; put semantics in higher layers.</li>
</ul>
<h2>Notes: ontology vs schema vs types in Kubo docs</h2>
<ul>
<li>Ontology: conceptual graph (node, daemon, CLI, gateway, RPC API, binary, OS).</li>
<li>Schema: implied structures (install recipes, $IPFS_PATH/api, feature lists).</li>
<li>Types: enforced interfaces (Go structs, CLI args, HTTP API surface).</li>
<li>Example: &quot;brew install ipfs&quot; is a schema instance of install recipes.</li>
<li>Tension: humans reason at ontology/schema; machines enforce types.</li>
</ul>
<h2>Core project: fold-engine (website implementation)</h2>
<h3>Explicit problem</h3>
<ul>
<li>Describe what fold-engine is, why it exists, and how it works inside Basis.</li>
</ul>
<h3>Definitions</h3>
<ul>
<li>Fold-engine: computation layer that turns large object stores into bounded
Markdown folds.</li>
<li>Fold: schema-bound, cognitively-sized slice (3–5 items) that is navigable.</li>
<li>Object store: structured JSON items (local files, DB, APIs).</li>
<li>Schema-bound: each item has a type/shape contract.</li>
<li>Prompt layer/MCP: commands that advance folds without reactive UI.</li>
</ul>
<h3>Known facts</h3>
<ul>
<li>Basis uses folds as the primary interface: minimal Markdown views over
objects.</li>
<li>Fold model uses Borel/σ-algebra metaphors for symbolic sets and refinement.</li>
<li>Markdown renderer is dumb; fold-engine is the brain.</li>
<li>Folds enforce cognitive limits (~4±1 items).</li>
<li>Future ingestion includes external APIs (e.g., calendars).</li>
</ul>
<h3>Constraints (inferred)</h3>
<ul>
<li>Low cognitive load per view.</li>
<li>Deterministic, auditable fold transitions.</li>
<li>Schema-first structure; no loose blobs.</li>
<li>Avoid prompt fatigue; favor agent-driven navigation.</li>
<li>Stable, composable semantics over clever UX.</li>
</ul>
<h3>Slot-based schema</h3>
<ul>
<li>Input: object store + schema registry + fold state.</li>
<li>Query: symbolic filter/set expression.</li>
<li>Projection: fields chosen for display.</li>
<li>Bounding: enforce item-count limits + grouping.</li>
<li>Navigation: car/cdr paging, drill-in, tail, backtrack.</li>
<li>Caching: memoize fold surfaces + stable IDs.</li>
<li>Audit: explainability of selection and ordering.</li>
<li>Output: Markdown surface + machine-readable fold token.</li>
</ul>
<h3>Derived conditions</h3>
<ul>
<li>A fold is a bounded viewport over a symbolic set, not just a list.</li>
<li>Continuity matters: the tail remains reachable.</li>
<li>Rendering is schema-guided, not ad-hoc.</li>
<li>Deterministic selection: same inputs + state → same surface.</li>
<li>car/cdr is a navigation semantics, not a data structure.</li>
</ul>
<h3>One-sentence definition</h3>
<ul>
<li>Fold-engine is a schema-aware view generator that emits small navigable
Markdown folds from large structured data.</li>
</ul>
<h3>Core responsibilities</h3>
<ul>
<li>Select items via symbolic queries (filter/intersect/union).</li>
<li>Project items into minimal display forms.</li>
<li>Bound the view to 3–5 items.</li>
<li>Navigate across folds (next/refine/open/back/tail).</li>
<li>Cache and stabilize fold identity.</li>
<li>Explain why a fold exists and why items appear.</li>
</ul>
<h3>What it is not</h3>
<ul>
<li>Not a reactive UI framework.</li>
<li>Not a markdown editor.</li>
<li>Not summarizer-first.</li>
<li>Not “a list of everything.”</li>
</ul>
<h3>Why it’s neat</h3>
<ul>
<li>Mirrors cognitive behavior: bounded slice, then move.</li>
<li>σ-algebra framing enables compositional refinement.</li>
<li>LLM-native by design: bounded context, stable state, deterministic
transitions.</li>
</ul>
<h3>Example mental model</h3>
<ul>
<li>Object store: tasks/events/journal entries.</li>
<li>Fold: “Heat-stressed cucumber care.”</li>
<li>4 actionable items, each schema-bound.</li>
<li>Next reveals tail; refine intersects with a schedule; open drills into full
detail.</li>
</ul>
<h3>Reduced summary</h3>
<ul>
<li>Fold-engine = Basis’s attention computation: schema + state → tiny Markdown
fold + navigable tails.</li>
</ul>
